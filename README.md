# LSJSwiftMaster

## 개요
LSJSwiftMaster는 Swift 마스터리를 목표로 다양한 필수 및 도전 문제를 해결하는 프로젝트입니다. Swift의 클로저, 고차 함수, 제네릭, 객체 지향 프로그래밍(OOP) 및 프로토콜 기반 설계를 포함한 다양한 개념을 연습합니다.

---

## 1️⃣ 필수 문제 1 - 클로저 및 고차 함수 활용

### ✅ 구현 내용
- 두 개의 `Int` 값을 받아 `String`을 반환하는 클로저를 작성
- 해당 클로저를 `sum` 상수에 저장하고, 호출하는 코드 작성
- 동일한 타입의 클로저를 매개변수로 받고 반환 값이 없는 `calculate` 함수 작성

### 🔹 실행 예제
```swift
print(sum(1, 2)) // "두 수의 합은 3입니다"
calculate(sumClousre: sum) // "두 수의 합은 7입니다" 출력
```

---

## 2️⃣ 필수 문제 2 - 고차 함수 및 체이닝

### ✅ 구현 내용
- `forEach`를 `map`으로 변환하여 코드 개선
- `map`과 `filter`를 활용한 데이터 변환
- 직접 `myMap` 함수를 구현하여 기존 `map`을 대체

### 🔹 실행 예제
```swift
print(myMap([1, 2, 3, 4, 5]) { String($0) })
// ["1", "2", "3", "4", "5"]
```

---

## 3️⃣ 필수 문제 3 - 제네릭 및 제약조건 활용

### ✅ 구현 내용
- `Int` 배열과 `String` 배열에서 짝수번째 요소 제거하는 함수 작성 (`a`, `b` 함수)
- 이를 제네릭을 사용하여 하나의 함수 (`c`)로 통합
- `Numeric` 프로토콜을 적용하여 숫자 배열에만 적용 가능한 함수 (`d`) 추가

### 🔹 실행 예제
```swift
print(c([1, 2, 3, 4, 5])) // [1, 3, 5]
print(c(["가", "나", "다", "라", "마"])) // ["가", "다", "마"]
```

---

## 4️⃣ 도전 문제 1 - 객체 지향 설계(OOP)

### ✅ 구현 내용
- `Car` 클래스 설계 (브랜드, 모델, 연식, 엔진)
- `ElectricCar`, `HybridCar`를 상속하여 확장
- `HybridCar`는 엔진 변경 기능 (`switchEngine(to:)`) 추가
- 클래스 상속의 장점과 단점에 대한 분석

### 🔹 실행 예제
```swift
let hybrid = HybridCar(brand: "Toyota", model: "Prius", year: "2023")
hybrid.switchEngine(to: HydrogenEngine())
// "엔진 교체 완료: Hydrogen 엔진으로 변경되었습니다." 출력
```

---

## 5️⃣ 도전 문제 2 - 프로토콜 기반 설계

### ✅ 구현 내용
- `PEngine` 프로토콜 정의 및 `PElectricEngine`, `PHydrogenEngine` 클래스 구현
- `PCar` 프로토콜 정의 및 `PBasicCar` 클래스 구현
- 상속과 프로토콜을 활용한 설계 방식 비교

### 🔹 상속 vs 프로토콜 분석
**상속의 장점**
- 코드 재사용이 용이
- 다형성 지원

**상속의 단점**
- 단일 상속만 가능하여 확장성이 낮음
- 깊은 상속 구조는 유지보수 어려움

**프로토콜의 장점**
- 다중 채택 가능
- 기능을 명확하게 분리하여 응집도 향상

**프로토콜의 단점**
- 기본 구현이 없으면 중복 코드 발생 가능
- 저장 프로퍼티 추가 불가능

